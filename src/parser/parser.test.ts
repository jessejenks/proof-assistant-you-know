import { describe, it } from "node:test";
import * as assert from "node:assert";

import { Parser } from "./parser";
import { type Token, TokenKind, type Location, Lexer } from "./lexer";
import { SExpVisitor } from "../visitors/sexp";

class MockLexer {
    private i: number;
    constructor(private tokens: Token[]) {
        this.i = 0;
    }

    next(): Token {
        const t = this.tokens[this.i];
        this.i++;
        return t;
    }

    peek(): Token {
        return this.tokens[this.i];
    }

    eof() {
        return this.i >= this.tokens.length;
    }
}

const location: Location = { line: 1, column: 1 };

describe("Parser", () => {
    const testTable: [string, Token[], string][] = [
        [
            "simple",
            [
                { kind: TokenKind.TheoremKeyword, location },
                { kind: TokenKind.TypeVar, value: "True", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "exact", location },
                { kind: TokenKind.Identifier, value: "true", location },
                { kind: TokenKind.EOF, location },
            ],
            [
                "(Document",
                "  (Theorem",
                "    (Proposition True)",
                "    (Proof",
                "      (Application exact",
                "        (Identifier true)))))",
            ].join("\n"),
        ],
        [
            "implication is right associating",
            [
                { kind: TokenKind.TheoremKeyword, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "Q", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "R", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "S", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "exact", location },
                { kind: TokenKind.Identifier, value: "test", location },
                { kind: TokenKind.EOF, location },
            ],
            [
                "(Document",
                "  (Theorem",
                "    (Implication",
                "      (Proposition P)",
                "      (Implication",
                "        (Proposition Q)",
                "        (Implication",
                "          (Proposition R)",
                "          (Proposition S))))",
                "    (Proof",
                "      (Application exact",
                "        (Identifier test)))))",
            ].join("\n"),
        ],
        [
            "conjunction is left associating",
            [
                { kind: TokenKind.TheoremKeyword, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.And, location },
                { kind: TokenKind.TypeVar, value: "Q", location },
                { kind: TokenKind.And, location },
                { kind: TokenKind.TypeVar, value: "R", location },
                { kind: TokenKind.And, location },
                { kind: TokenKind.TypeVar, value: "S", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "exact", location },
                { kind: TokenKind.Identifier, value: "test", location },
                { kind: TokenKind.EOF, location },
            ],
            [
                "(Document",
                "  (Theorem",
                "    (Conjunction",
                "      (Conjunction",
                "        (Conjunction",
                "          (Proposition P)",
                "          (Proposition Q))",
                "        (Proposition R))",
                "      (Proposition S))",
                "    (Proof",
                "      (Application exact",
                "        (Identifier test)))))",
            ].join("\n"),
        ],
        [
            "disjunction is left associating",
            [
                { kind: TokenKind.TheoremKeyword, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.TypeVar, value: "Q", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.TypeVar, value: "R", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.TypeVar, value: "S", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "exact", location },
                { kind: TokenKind.Identifier, value: "test", location },
                { kind: TokenKind.EOF, location },
            ],
            [
                "(Document",
                "  (Theorem",
                "    (Disjunction",
                "      (Disjunction",
                "        (Disjunction",
                "          (Proposition P)",
                "          (Proposition Q))",
                "        (Proposition R))",
                "      (Proposition S))",
                "    (Proof",
                "      (Application exact",
                "        (Identifier test)))))",
            ].join("\n"),
        ],
        [
            "precedence",
            [
                { kind: TokenKind.TheoremKeyword, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "Q", location },
                { kind: TokenKind.And, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "R", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.TypeVar, value: "S", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "exact", location },
                { kind: TokenKind.Identifier, value: "test", location },
                { kind: TokenKind.EOF, location },
            ],
            [
                "(Document",
                "  (Theorem",
                "    (Implication",
                "      (Proposition P)",
                "      (Disjunction",
                "        (Conjunction",
                "          (Proposition Q)",
                "          (Negation",
                "            (Proposition R)))",
                "        (Proposition S)))",
                "    (Proof",
                "      (Application exact",
                "        (Identifier test)))))",
            ].join("\n"),
        ],
        [
            "precedence",
            [
                { kind: TokenKind.TheoremKeyword, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "Q", location },
                { kind: TokenKind.And, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "R", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.TypeVar, value: "S", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.LParen, location },
                { kind: TokenKind.TypeVar, value: "A", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "B", location },
                { kind: TokenKind.RParen, location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "exact", location },
                { kind: TokenKind.Identifier, value: "test", location },
                { kind: TokenKind.EOF, location },
            ],
            [
                "(Document",
                "  (Theorem",
                "    (Implication",
                "      (Proposition P)",
                "      (Disjunction",
                "        (Disjunction",
                "          (Conjunction",
                "            (Proposition Q)",
                "            (Negation",
                "              (Proposition R)))",
                "          (Proposition S))",
                "        (Implication",
                "          (Proposition A)",
                "          (Proposition B))))",
                "    (Proof",
                "      (Application exact",
                "        (Identifier test)))))",
            ].join("\n"),
        ],
        [
            "complex",
            [
                { kind: TokenKind.TheoremKeyword, location },
                { kind: TokenKind.Identifier, value: "example19_7", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.LParen, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.RParen, location },
                { kind: TokenKind.AssumeKeyword, location },
                { kind: TokenKind.Identifier, value: "g", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.LParen, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.RParen, location },
                { kind: TokenKind.LBrace, location },
                { kind: TokenKind.HaveKeyword, location },
                { kind: TokenKind.Identifier, value: "h1", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.AssumeKeyword, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.LBrace, location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "orIntroRight", location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.RBrace, location },
                { kind: TokenKind.HaveKeyword, location },
                { kind: TokenKind.Identifier, value: "h2", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Implies, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.AssumeKeyword, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.LBrace, location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "orIntroLeft", location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.RBrace, location },
                { kind: TokenKind.HaveKeyword, location },
                { kind: TokenKind.Identifier, value: "k", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.AssumeKeyword, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.LBrace, location },
                { kind: TokenKind.HaveKeyword, location },
                { kind: TokenKind.Identifier, value: "c", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "h1", location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "g", location },
                { kind: TokenKind.Identifier, value: "c", location },
                { kind: TokenKind.RBrace, location },
                { kind: TokenKind.HaveKeyword, location },
                { kind: TokenKind.Identifier, value: "l", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.AssumeKeyword, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.LBrace, location },
                { kind: TokenKind.HaveKeyword, location },
                { kind: TokenKind.Identifier, value: "c", location },
                { kind: TokenKind.Colon, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.Or, location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "h2", location },
                { kind: TokenKind.Not, location },
                { kind: TokenKind.TypeVar, value: "P", location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "g", location },
                { kind: TokenKind.Identifier, value: "c", location },
                { kind: TokenKind.RBrace, location },
                { kind: TokenKind.ByKeyword, location },
                { kind: TokenKind.Identifier, value: "l", location },
                { kind: TokenKind.Identifier, value: "k", location },
                { kind: TokenKind.RBrace, location },
                { kind: TokenKind.EOF, location },
            ],
            [
                "(Document",
                "  (Theorem example19_7",
                "    (Negation",
                "      (Negation",
                "        (Disjunction",
                "          (Proposition P)",
                "          (Negation",
                "            (Proposition P)))))",
                "    (Proof",
                "      (Assumption g",
                "        (Negation",
                "          (Disjunction",
                "            (Proposition P)",
                "            (Negation",
                "              (Proposition P))))",
                "        (Proof",
                "          (Step h1",
                "            (Implication",
                "              (Proposition P)",
                "              (Disjunction",
                "                (Proposition P)",
                "                (Negation",
                "                  (Proposition P))))",
                "            (Assumption",
                "              (Proposition P)",
                "              (Proof",
                "                (Application orIntroRight",
                "                  (Proposition P)))))",
                "          (Step h2",
                "            (Implication",
                "              (Negation",
                "                (Proposition P))",
                "              (Disjunction",
                "                (Proposition P)",
                "                (Negation",
                "                  (Proposition P))))",
                "            (Assumption",
                "              (Negation",
                "                (Proposition P))",
                "              (Proof",
                "                (Application orIntroLeft",
                "                  (Negation",
                "                    (Proposition P))))))",
                "          (Step k",
                "            (Negation",
                "              (Proposition P))",
                "            (Assumption",
                "              (Proposition P)",
                "              (Proof",
                "                (Step c",
                "                  (Disjunction",
                "                    (Proposition P)",
                "                    (Negation",
                "                      (Proposition P)))",
                "                  (Application h1",
                "                    (Proposition P)))",
                "                (Application g",
                "                  (Identifier c)))))",
                "          (Step l",
                "            (Negation",
                "              (Negation",
                "                (Proposition P)))",
                "            (Assumption",
                "              (Negation",
                "                (Proposition P))",
                "              (Proof",
                "                (Step c",
                "                  (Disjunction",
                "                    (Proposition P)",
                "                    (Negation",
                "                      (Proposition P)))",
                "                  (Application h2",
                "                    (Negation",
                "                      (Proposition P))))",
                "                (Application g",
                "                  (Identifier c)))))",
                "          (Application l",
                "            (Identifier k)))))))",
            ].join("\n"),
        ],
    ];

    for (let i = 0; i < testTable.length; i++) {
        const [name, tokenStream, expected] = testTable[i];
        it(`(${i}) ${name}`, () => {
            const parser = new Parser(new MockLexer(tokenStream) as any as Lexer);
            const doc = parser.parse();
            const visitor = new SExpVisitor(false, 2);
            visitor.visitDocument(doc);
            assert.strictEqual(visitor.getDocument(), expected);
        });
    }
});
